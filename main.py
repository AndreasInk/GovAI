# review_app.py
"""
⚖️  HOA Drift-Checker – Streamlit UI
-----------------------------------
Flags low-similarity summary sentences, lets the board edit them,
and commits accepted edits back to GitHub as a pull request.

Quick-start
-----------
1.  pip install streamlit PyGithub streamlit-diff-viewer openai tiktoken
2.  export OPENAI_API_KEY=…
    export GITHUB_TOKEN=ghp_xxx
    export GITHUB_REPO=username/bylaws-rewrite   #   org/repo
3.  Have three companion files in the same folder:
    • chunks.json        – list[str]   chunk_id → source text
    • chunk_vecs.npy     – NumPy array of embeddings (same order)
    • flags.json         – list[tuple(similarity, sentence, [ids])]
"""
from __future__ import annotations
import os, json, uuid, time
from pathlib import Path
from typing import List, Tuple

import re
from scipy.spatial.distance import cosine

import numpy as np
import streamlit as st
from st_diff_viewer import diff_viewer
from github import Github, InputGitAuthor

import ai  # your helper wrapper
from tiktoken import get_encoding           # just for token count display

# ------------------------------------------------------------------
# ⬇️  Load pre-computed artefacts  (produced by the notebook prototype)
# ------------------------------------------------------------------
DATA_DIR = Path(__file__).parent / "data"
chunks: List[str] = json.loads((DATA_DIR / "chunks.json").read_text())
embeddings = np.load(DATA_DIR / "chunk_vecs.npy")
flags: List[Tuple[float, str, List[int]]] = json.loads((DATA_DIR / "flags.json").read_text())
# Store flags in session_state, sorted, for possible re-flagging
if "flags" not in st.session_state:
    flags.sort(key=lambda tup: tup[0])
    st.session_state.flags = flags

# Mapping from chunk_id (str) -> integer index in chunks list
ID2IDX_PATH = DATA_DIR / "id_to_idx.json"
id_to_idx: dict[str, int] = {}
if ID2IDX_PATH.exists():
    id_to_idx = json.loads(ID2IDX_PATH.read_text())
    # normalise keys to lower-case for robustness
    id_to_idx = {k.lower(): v for k, v in id_to_idx.items()}

def _cid_to_idx(cid: str | int) -> int | None:
    """Return integer index for a chunk ID (str or int)."""
    if isinstance(cid, int):
        return cid if 0 <= cid < len(chunks) else None
    return id_to_idx.get(str(cid).lower())

ENC = get_encoding("cl100k_base")

# ---------------------------------------------
# 🔐  GitHub client  (lazy-init on first commit)
# ---------------------------------------------
def _gh_client() -> Github:
    token = os.getenv("GITHUB_TOKEN")
    if not token:
        st.error("GITHUB_TOKEN env var missing – cannot push PRs.")
        st.stop()
    return Github(token)


# ----------------------------------------------------------
# 🛠️  Utility – open a PR with the edited draft.md content
# ----------------------------------------------------------
def create_or_update_pr(new_content: str, user_name: str = "HOA Reviewer") -> None:
    repo_full = os.getenv("GITHUB_REPO")
    if not repo_full:
        st.error("Set GITHUB_REPO (e.g. 'user/repo') to enable PRs.")
        return

    gh = _gh_client()
    repo = gh.get_repo(repo_full)

    base = repo.get_branch("main")
    branch_name = f"hoa-drift-fix/{int(time.time())}"
    repo.create_git_ref(ref=f"refs/heads/{branch_name}", sha=base.commit.sha)

    commit_message = "HOA summary edits via Streamlit reviewer"
    author = InputGitAuthor(user_name, f"{user_name.replace(' ','.').lower()}@example.com")
    repo.update_file(
        path="draft.md",
        message=commit_message,
        content=new_content,
        sha=repo.get_contents("draft.md", ref=branch_name).sha,
        branch=branch_name,
        author=author,
    )
    pr = repo.create_pull(
        title="🏷️ HOA drift fixes",
        body="Auto-generated by Streamlit reviewer; please squash-merge.",
        head=branch_name,
        base="main",
    )
    st.success(f"✅ Pull Request created: {pr.html_url}")


# -------------------------
# 🌐  Streamlit page config
# -------------------------
st.set_page_config(page_title="HOA Drift Checker", page_icon="📜", layout="wide")
st.title("📜 HOA Document Drift Checker")

st.sidebar.markdown(f"**{len(st.session_state.flags)} flags** loaded · Source chunks: **{len(chunks)}**")

# Global “edited draft” buffer (one long string)
if "draft_buffer" not in st.session_state:
    st.session_state.draft_buffer = Path("draft.md").read_text()

# --------------------------------------------------------------------
# ---------- Re-flagging helper (uses cached chunk embeddings) ----------
# Accept IDs like `[C-123]`, `[C-Bylaws_5_3]`, or `[Bylaws_5_3]`
_CIT_RE = re.compile(r"(?:C-)?([\w\-]+)")

def _make_flags(draft_text: str, threshold: float = 0.85):
    """Return fresh flags list from *draft_text* (markdown)."""
    sentences = re.split(r"(?<=[.!?])\s+", draft_text)
    new_flags = []
    for s in sentences:
        src_ids = [x.lower() for x in _CIT_RE.findall(s)]
        if not src_ids:
            continue
        s_vec = ai.embed(s)  # (D,)
        idxs = [_cid_to_idx(cid) for cid in src_ids if _cid_to_idx(cid) is not None]
        if not idxs:
            continue  # no valid matching chunks
        worst = min(1 - cosine(s_vec, embeddings[i]) for i in idxs)
        if worst < threshold:
            new_flags.append((round(float(worst), 4), s, src_ids))
    new_flags.sort(key=lambda tup: tup[0])
    return new_flags

# --------------------------------------------------------------------
# 🚧  Iterate through flagged sentences – one expander per flag
# --------------------------------------------------------------------

# Optional mode switch for future extensibility (not required by prompt, but for context)
mode = "Review Flags"
if mode == "Review Flags":
    # ---------- Optional re-flagging ----------
    uploaded = st.sidebar.file_uploader("Upload a *new* draft (Markdown)", type=["md", "txt"])
    if uploaded and st.sidebar.button("🔄 Re‑run flagging"):
        draft_bytes = uploaded.read()
        draft_text = draft_bytes.decode("utf-8", errors="ignore")
        with st.spinner("Computing new flags …"):
            st.session_state.flags = _make_flags(draft_text)
            st.success(f"✅ Re‑flagged draft – {len(st.session_state.flags)} flags found.")

    for idx, (sim, sent, ids) in enumerate(st.session_state.flags, 1):
        with st.expander(f"({idx}/{len(st.session_state.flags)}) Similarity {sim:.2f}  |  {sent[:80]}…"):
            col1, col2 = st.columns([1, 1])

            with col1:
                st.markdown("##### ✏️ **Edit summary sentence**")
                edited = st.text_area(
                    "Sentence", value=sent, key=f"edit-{idx}", height=80, label_visibility="collapsed"
                )
                token_len = len(ENC.encode(edited))
                st.caption(f"{token_len} tokens")

            with col2:
                st.markdown("##### 📖 **Source chunk(s)**")
                for cid in ids:
                    idx = _cid_to_idx(cid)
                    if idx is not None:
                        st.write(chunks[idx])
                        st.divider()
                    else:
                        st.warning(f"⚠️ Source chunk '{cid}' not found.")

            # 🖍️  Diff viewer (only show if edited != original)
            if edited.strip() != sent.strip():
                st.markdown("##### 🔍 Diff")
                diff_viewer(sent, edited, lang="md")

            # Keep a local mapping to inject back into full draft later
            if "edits" not in st.session_state:
                st.session_state.edits = {}
            st.session_state.edits[sent] = edited

# --------------------------------------------------------------------
# 💾  Commit all edits – rewrites draft.md and opens a PR
# --------------------------------------------------------------------
st.sidebar.divider()
if st.sidebar.button("🚀 Commit **all** accepted edits → GitHub PR"):
    # Apply edits to the draft buffer
    new_draft = st.session_state.draft_buffer
    for original, replacement in st.session_state.edits.items():
        if original != replacement:
            new_draft = new_draft.replace(original, replacement)

    create_or_update_pr(new_draft, user_name=st.sidebar.text_input("Your name", value="HOA Reviewer"))